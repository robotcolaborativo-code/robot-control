#include <WiFi.h>
#include <ESP32Servo.h>
#include <vector>
#include <HTTPClient.h>

// ======================= CONFIG =======================
const char* ssid = "d24cc2";
const char* password = "228059445";
const uint16_t TCP_PORT_DEFAULT = 8080;

// CONEXI√ìN AUTOM√ÅTICA ACTIVADA
const bool AUTO_WIFI = true;

// Configuraci√≥n para dashboard en la nube
const char* CLOUD_API_URL = "https://tu-api.onrender.com";
const String ESP32_ID = "cobot_01";

// ======================= HARDWARE =======================
const int WIFI_LED = 2;
const int STATUS_LED = 4;

int stepPins[4] = {12, 26, 33, 18};
int dirPins[4]  = {14, 25, 32, 19};

Servo garra;
int pinServo = 23;
// ‚úÖ GARRA CORREGIDA: 100¬∞ = Abierto, 0¬∞ = Cerrado
int posAbierta = 100;
int posCerrada = 0;

// ======================= ESTADO =======================
WiFiServer server(TCP_PORT_DEFAULT);
WiFiClient clientTCP;
bool wifi_server_running = false;
bool wifi_connecting = false;

// Estado de conexi√≥n mejorado
enum WiFiStatus {
  WIFI_DISCONNECTED,
  WIFI_CONNECTING, 
  WIFI_CONNECTED,
  WIFI_CLOUD_READY
};
WiFiStatus wifi_status = WIFI_DISCONNECTED;

String inputString = "";
bool motoresActivos = false;
bool emergencyStop = false;
float current_deg[5] = {0,0,0,0,0};

// ‚úÖ MODOS DE VELOCIDAD FIJOS
const int VELOCIDAD_M3_FIJA = 35;    // 35 RPM para M3
const int VELOCIDAD_M4_FIJA = 1000;  // 1000 RPM para M4

// TIMING OPTIMIZADO - M√ÅS R√ÅPIDO
bool ledState = LOW;
unsigned long ledLastToggle = 0;
const unsigned long LED_BLINK_MS = 300;
unsigned long lastWifiCheck = 0;
const unsigned long WIFI_CHECK_INTERVAL = 20000;
unsigned long lastCloudUpdate = 0;
const unsigned long CLOUD_UPDATE_INTERVAL = 25000;
unsigned long lastCommandTime = 0;
bool commandInProgress = false;

// Prototipos
void procesarComando(String cmd);
void start_wifi_server(uint16_t port = TCP_PORT_DEFAULT);
void stop_wifi_server();
void mantener_wifi();
void update_wifi_led();
void moverMotorPasos(int motor, long pasos, bool sentidoHorario, int velocidad);
long grados_a_pasos(float grados);
void moverMotorPorDeltaDeg(int motor, float delta_deg, int velocidad);
void moverMotorSecuencialDesdePos(float target_deg[5], int velocidad);

// NUEVOS PROTOTIPOS OPTIMIZADOS
void enviarEstadoALaNube();
void verificarConexionWiFi();
void actualizarEstadoWiFi();
String generarJSONEstado();
void procesarComandosRapido();
void procesarComandoRapido(String cmd);

// ‚úÖ NUEVA FUNCI√ìN: Aplicar modo de velocidad seg√∫n motor
int aplicarModoVelocidad(int motor, int velocidad_solicitada);

// ======================= SETUP =======================
void setup() {
  Serial.begin(115200);
  Serial.setTimeout(10);
  delay(200);
  Serial.println("\nüîß Iniciando ESP32 Cobot...");
  Serial.println("ü§ñ ESP32 listo...");

  pinMode(WIFI_LED, OUTPUT);
  pinMode(STATUS_LED, OUTPUT);
  digitalWrite(WIFI_LED, LOW);
  digitalWrite(STATUS_LED, LOW);
  ledState = LOW;

  for (int i = 0; i < 4; ++i) {
    pinMode(stepPins[i], OUTPUT);
    pinMode(dirPins[i], OUTPUT);
    digitalWrite(stepPins[i], LOW);
    digitalWrite(dirPins[i], LOW);
  }

  garra.attach(pinServo);
  garra.write(posAbierta);
  current_deg[4] = posAbierta;

  motoresActivos = false;
  emergencyStop = false;

  // CONEXI√ìN AUTOM√ÅTICA ACTIVADA
  if (AUTO_WIFI) {
    Serial.println("üì° Iniciando conexi√≥n WiFi autom√°tica...");
    start_wifi_server(TCP_PORT_DEFAULT);
  }
}

// ======================= LOOP OPTIMIZADO =======================
void loop() {
  procesarComandosRapido();
  
  mantener_wifi();
  verificarConexionWiFi();
  update_wifi_led();

  if (!commandInProgress && wifi_status == WIFI_CONNECTED && millis() - lastCloudUpdate > CLOUD_UPDATE_INTERVAL) {
    enviarEstadoALaNube();
    lastCloudUpdate = millis();
  }

  delay(1);
}

// ‚úÖ NUEVA FUNCI√ìN: Aplicar modos de velocidad
int aplicarModoVelocidad(int motor, int velocidad_solicitada) {
  switch(motor) {
    case 2: // M3 (0-indexed)
      return VELOCIDAD_M3_FIJA; // 35 RPM fijo
    case 3: // M4 (0-indexed)  
      return VELOCIDAD_M4_FIJA; // 1000 RPM fijo
    default: // M1 y M2 - control completo 1-1500 RPM
      return constrain(velocidad_solicitada, 1, 1500);
  }
}

// ======================= NUEVAS FUNCIONES OPTIMIZADAS =======================
void procesarComandosRapido() {
  while (Serial.available()) {
    char c = (char)Serial.read();
    inputString += c;
    
    if (c == '\n' || c == '\r') {
      String line = inputString;
      line.trim();
      if (line.length() > 0) {
        procesarComandoRapido(line);
      }
      inputString = "";
    }
  }
  
  if (wifi_server_running) {
    if (!clientTCP || !clientTCP.connected()) {
      WiFiClient candidate = server.available();
      if (candidate && candidate.connected()) {
        clientTCP = candidate;
        Serial.println("üåê Cliente TCP conectado.");
      }
    }

    if (clientTCP && clientTCP.connected() && clientTCP.available()) {
      String cmd = clientTCP.readStringUntil('\n');
      cmd.trim();
      if (cmd.length() > 0) {
        Serial.printf("üåê [WiFi] Recibido: %s\n", cmd.c_str());
        procesarComandoRapido(cmd);
        clientTCP.println("OK: " + cmd);
      }
    }
  }
}

void procesarComandoRapido(String cmd) {
  cmd.trim();
  if (cmd.length() == 0) return;
  
  lastCommandTime = millis();
  commandInProgress = true;

  String up = cmd;
  up.toUpperCase();

  // Comandos INMEDIATOS
  if (up == "ON") {
    emergencyStop = false;
    motoresActivos = true;
    Serial.println("üîå Motores energizados.");
    commandInProgress = false;
    return;
  }
  
  if (up == "OFF") {
    motoresActivos = false;
    Serial.println("‚öôÔ∏è Motores apagados.");
    commandInProgress = false;
    return;
  }
  
  if (up == "ABRIR") {
    if (motoresActivos && !emergencyStop) {
      garra.write(posAbierta);
      current_deg[4] = posAbierta;
      Serial.println("üü¢ Garra abierta (100¬∞)");
    } else Serial.println("‚ö†Ô∏è No energizado o E-STOP.");
    commandInProgress = false;
    return;
  }
  
  if (up == "CERRAR") {
    if (motoresActivos && !emergencyStop) {
      garra.write(posCerrada);
      current_deg[4] = posCerrada;
      Serial.println("üî¥ Garra cerrada (0¬∞)");
    } else Serial.println("‚ö†Ô∏è No energizado o E-STOP.");
    commandInProgress = false;
    return;
  }
  
  if (up == "STOP" || up == "ESTOP" || up == "E-STOP") {
    emergencyStop = true;
    motoresActivos = false;
    for (int i = 0; i < 4; ++i) {
      digitalWrite(stepPins[i], LOW);
      digitalWrite(dirPins[i], LOW);
    }
    Serial.println("‚õî EMERGENCY STOP activado.");
    commandInProgress = false;
    return;
  }

  if (up == "RESET") {
    emergencyStop = false;
    motoresActivos = false;
    for (int i = 0; i < 4; ++i) current_deg[i] = 0;
    garra.write(posAbierta);
    current_deg[4] = posAbierta;
    Serial.println("üîÅ RESET completado.");
    commandInProgress = false;
    return;
  }

  // Comandos que requieren movimiento
  if (up.startsWith("M")) {
    procesarComando(cmd);
  } else if (up.startsWith("POS")) {
    procesarComando(cmd);
  } else if (up.startsWith("MODE:")) {
    procesarComando(cmd);
  } else {
    Serial.printf("üì® Comando desconocido: %s\n", cmd.c_str());
    commandInProgress = false;
  }
}

void verificarConexionWiFi() {
  if (millis() - lastWifiCheck > WIFI_CHECK_INTERVAL) {
    if (WiFi.status() != WL_CONNECTED && wifi_status != WIFI_DISCONNECTED) {
      Serial.println("‚ö†Ô∏è WiFi desconectado. Intentando reconectar...");
      wifi_status = WIFI_DISCONNECTED;
      if (AUTO_WIFI) {
        start_wifi_server(TCP_PORT_DEFAULT);
      }
    } else if (WiFi.status() == WL_CONNECTED && wifi_status == WIFI_DISCONNECTED) {
      Serial.println("‚úÖ WiFi reconectado!");
      wifi_status = WIFI_CONNECTED;
    }
    lastWifiCheck = millis();
  }
}

void enviarEstadoALaNube() {
  if (WiFi.status() == WL_CONNECTED) {
    HTTPClient http;
    
    String url = String(CLOUD_API_URL) + "/api/status/update";
    http.begin(url);
    http.addHeader("Content-Type", "application/json");
    http.setTimeout(2000);
    
    String jsonData = generarJSONEstado();
    
    int httpCode = http.POST(jsonData);
    
    if (httpCode == 200) {
      Serial.println("üì° Estado enviado a la nube ‚úÖ");
      digitalWrite(STATUS_LED, HIGH);
    } else {
      Serial.printf("‚ùå Error enviando a nube: %d\n", httpCode);
      digitalWrite(STATUS_LED, LOW);
    }
    
    http.end();
  }
}

String generarJSONEstado() {
  String json = "{";
  json += "\"esp32_id\":\"" + ESP32_ID + "\",";
  json += "\"motor1_deg\":" + String(current_deg[0]) + ",";
  json += "\"motor2_deg\":" + String(current_deg[1]) + ",";
  json += "\"motor3_deg\":" + String(current_deg[2]) + ",";
  json += "\"motor4_deg\":" + String(current_deg[3]) + ",";
  json += "\"garra_state\":\"" + String(current_deg[4] == posCerrada ? "CERRADA" : "ABIERTA") + "\",";
  json += "\"garra_deg\":" + String(current_deg[4]) + ","; // ‚úÖ Nuevo: grados de garra
  json += "\"emergency_stop\":" + String(emergencyStop ? "true" : "false") + ",";
  json += "\"motors_active\":" + String(motoresActivos ? "true" : "false") + ",";
  json += "\"connection_mode\":\"WIFI\",";
  json += "\"wifi_signal\":" + String(WiFi.RSSI());
  json += "}";
  return json;
}

void actualizarEstadoWiFi() {
  if (WiFi.status() == WL_CONNECTED) {
    wifi_status = WIFI_CONNECTED;
  } else {
    wifi_status = WIFI_DISCONNECTED;
  }
}

// ======================= LED MEJORADO =======================
void update_wifi_led() {
  unsigned long now = millis();
  
  switch(wifi_status) {
    case WIFI_DISCONNECTED:
      if (now - ledLastToggle >= 250) {
        ledState = !ledState;
        digitalWrite(WIFI_LED, ledState);
        ledLastToggle = now;
      }
      break;
      
    case WIFI_CONNECTING:
      if (now - ledLastToggle >= 500) {
        ledState = !ledState;
        digitalWrite(WIFI_LED, ledState);
        ledLastToggle = now;
      }
      break;
      
    case WIFI_CONNECTED:
      if (!ledState) {
        digitalWrite(WIFI_LED, HIGH);
        ledState = HIGH;
      }
      break;
      
    case WIFI_CLOUD_READY:
      if (now - ledLastToggle >= 1000) {
        ledState = !ledState;
        digitalWrite(WIFI_LED, ledState);
        ledLastToggle = now;
      }
      break;
  }
}

// ======================= WIFI FUNCIONES OPTIMIZADAS =======================
void start_wifi_server(uint16_t port) {
  if (wifi_server_running) {
    Serial.println("üü¢ Wi-Fi server ya corriendo.");
    return;
  }

  Serial.printf("üîå Intentando conectar Wi-Fi a '%s' ...\n", ssid);
  wifi_connecting = true;
  wifi_status = WIFI_CONNECTING;
  WiFi.mode(WIFI_STA);
  WiFi.begin(ssid, password);

  unsigned long start = millis();
  const unsigned long timeout = 10000;
  
  while (WiFi.status() != WL_CONNECTED && millis() - start < timeout) {
    delay(300);
    Serial.print(".");
  }

  wifi_connecting = false;

  if (WiFi.status() == WL_CONNECTED) {
    Serial.println("\n‚úÖ Conectado al Wi-Fi!");
    Serial.print("üì° IP local: "); Serial.println(WiFi.localIP());
    Serial.print("üì∂ Se√±al WiFi: ");
    Serial.print(WiFi.RSSI());
    Serial.println(" dBm");
    
    server.begin(port);
    wifi_server_running = true;
    wifi_status = WIFI_CONNECTED;
    Serial.printf("üü¢ Servidor TCP activo en puerto %d\n", port);
    Serial.println("üåê Listo para conexiones TCP y env√≠o a la nube");
    
  } else {
    Serial.println("\n‚ùå No se pudo conectar al Wi-Fi.");
    wifi_server_running = false;
    wifi_status = WIFI_DISCONNECTED;
    WiFi.disconnect(true);
  }
}

void stop_wifi_server() {
  if (!wifi_server_running && WiFi.status() != WL_CONNECTED) {
    Serial.println("üî¥ stop_wifi_server() llamado pero no hab√≠a servidor/wi-fi activo.");
    return;
  }
  if (clientTCP && clientTCP.connected()) {
    clientTCP.stop();
    Serial.println("üîå Cliente TCP desconectado.");
  }
  server.stop();
  WiFi.disconnect(true);
  wifi_server_running = false;
  wifi_connecting = false;
  wifi_status = WIFI_DISCONNECTED;
  Serial.println("üî¥ Wi-Fi detenido.");
}

void mantener_wifi() {
  if (AUTO_WIFI && !wifi_server_running) {
    if (WiFi.status() != WL_CONNECTED && !wifi_connecting) {
      static unsigned long lastTry = 0;
      if (millis() - lastTry > 12000) {
        Serial.println("üîÑ AUTO_WIFI: intentando reconectar...");
        start_wifi_server(TCP_PORT_DEFAULT);
        lastTry = millis();
      }
    }
  }
}

// ======================= COMANDOS CON MEJORAS DE VELOCIDAD =======================
void procesarComando(String cmd) {
  cmd.trim();
  if (cmd.length() == 0) return;

  String up = cmd;
  up.toUpperCase();

  // MODE handlers
  if (up.startsWith("MODE:WIFI")) {
    Serial.println("üì° Petici√≥n: MODE:WIFI");
    start_wifi_server(TCP_PORT_DEFAULT);
    commandInProgress = false;
    return;
  }
  if (up.startsWith("MODE:SERIAL")) {
    Serial.println("üîå Petici√≥n: MODE:SERIAL");
    stop_wifi_server();
    commandInProgress = false;
    return;
  }

  // Motor direct command: M#,DIR,pasos,vel
  if (up.startsWith("M")) {
    int idx1 = cmd.indexOf(',');
    int idx2 = cmd.indexOf(',', idx1 + 1);
    int idx3 = cmd.indexOf(',', idx2 + 1);
    if (idx1 == -1 || idx2 == -1 || idx3 == -1) {
      Serial.println("‚ùå Formato inv√°lido (M#,...).");
      commandInProgress = false;
      return;
    }
    int motor = cmd.substring(1, idx1).toInt() - 1; // Convertir a 0-indexed
    String direccion = cmd.substring(idx1 + 1, idx2);
    int pasos = cmd.substring(idx2 + 1, idx3).toInt();
    int velocidad_solicitada = cmd.substring(idx3 + 1).toInt();
    
    if (motor >= 0 && motor < 4) {
      if (motoresActivos && !emergencyStop) {
        // ‚úÖ APLICAR MODO DE VELOCIDAD SEG√öN MOTOR
        int velocidad_final = aplicarModoVelocidad(motor, velocidad_solicitada);
        
        bool sentidoHorario = (direccion == "H");
        moverMotorPasos(motor, pasos, sentidoHorario, velocidad_final);
        float grados = ((float)pasos / 200.0) * 360.0;
        current_deg[motor] = fmod((current_deg[motor] + grados + 360.0), 360.0);
        
        // ‚úÖ INFORMAR VELOCIDAD APLICADA
        Serial.printf("‚úÖ Motor %d movido (%.1f deg, vel=%d", motor+1, grados, velocidad_final);
        if (motor == 2 && velocidad_final != velocidad_solicitada) {
          Serial.print(" - MODO M3: 35 RPM FIJO");
        } else if (motor == 3 && velocidad_final != velocidad_solicitada) {
          Serial.print(" - MODO M4: 1000 RPM FIJO");
        }
        Serial.println(")");
      } else Serial.println("‚ö†Ô∏è No energizado o E-STOP.");
    } else Serial.println("‚ùå Motor fuera de rango.");
    commandInProgress = false;
    return;
  }

  // POS command: POS,d1,d2,d3,d4,d5,vel
  if (up.startsWith("POS")) {
    int posComma = cmd.indexOf(',');
    String rest;
    if (posComma != -1) rest = cmd.substring(posComma + 1);
    else {
      Serial.println("‚ùå POS formato inv√°lido.");
      commandInProgress = false;
      return;
    }

    std::vector<String> parts;
    int start = 0;
    for (int i = 0; i <= rest.length(); ++i) {
      if (i == rest.length() || rest.charAt(i) == ',') {
        parts.push_back(rest.substring(start, i));
        start = i + 1;
      }
    }
    if ((int)parts.size() < 6) {
      Serial.println("‚ùå POS formato inv√°lido. Use: POS,d1,d2,d3,d4,d5,vel");
      commandInProgress = false;
      return;
    }

    float targets[5];
    for (int i = 0; i < 5; ++i) targets[i] = parts[i].toFloat();
    int vel = parts[5].toInt();

    if (!motoresActivos || emergencyStop) {
      Serial.println("‚ö†Ô∏è Motores desenergizados o E-STOP.");
      commandInProgress = false;
      return;
    }
    moverMotorSecuencialDesdePos(targets, vel);
    return;
  }

  Serial.printf("üì® Comando desconocido: %s\n", cmd.c_str());
  commandInProgress = false;
}

// ======================= MOVIMIENTOS OPTIMIZADOS =======================
long grados_a_pasos(float grados) {
  float pasos = (grados/360.0) * 200.0;
  return (long)round(abs(pasos));
}

void moverMotorPasos(int motor, long pasos, bool sentidoHorario, int velocidad) {
  if (motor < 0 || motor > 3) return;
  if (pasos <= 0) return;
  digitalWrite(dirPins[motor], sentidoHorario ? HIGH : LOW);
  delayMicroseconds(100);
  
  int delayMicros = map(velocidad, 1, 1500, 1200, 200); // ‚úÖ Actualizado para 1500 RPM max
  delayMicros = constrain(delayMicros, 200, 1200);
  
  for (long i=0; i<pasos; i++) {
    digitalWrite(stepPins[motor], HIGH);
    delayMicroseconds(delayMicros);
    digitalWrite(stepPins[motor], LOW);
    delayMicroseconds(delayMicros);
    if (emergencyStop) {
      Serial.println("‚õî E-STOP detectado. Parando motor.");
      commandInProgress = false;
      return;
    }
  }
  commandInProgress = false;
}

void moverMotorPorDeltaDeg(int motor, float delta_deg, int velocidad) {
  if (motor < 0 || motor > 3) return;
  if (abs(delta_deg) < 0.5) return;
  
  // ‚úÖ APLICAR MODO DE VELOCIDAD
  int velocidad_final = aplicarModoVelocidad(motor, velocidad);
  
  bool sentidoHorario = (delta_deg > 0);
  long pasos = grados_a_pasos(abs(delta_deg));
  moverMotorPasos(motor, pasos, sentidoHorario, velocidad_final);
  current_deg[motor] += delta_deg;
  while (current_deg[motor] >= 360.0) current_deg[motor] -= 360.0;
  while (current_deg[motor] < 0.0) current_deg[motor] += 360.0;
}

void moverMotorSecuencialDesdePos(float target_deg[5], int velocidad) {
  Serial.println("‚û° POS: iniciando secuencia...");
  for (int m=0; m<4; m++) {
    float delta = target_deg[m] - current_deg[m];
    while (delta > 180.0) delta -= 360.0;
    while (delta < -180.0) delta += 360.0;
    if (abs(delta) >= 0.5) {
      // ‚úÖ APLICAR MODO DE VELOCIDAD POR MOTOR
      int velocidad_motor = aplicarModoVelocidad(m, velocidad);
      Serial.printf("‚û°Ô∏è M%d: delta=%.2f deg -> %ld pasos (vel=%d", m+1, delta, grados_a_pasos(abs(delta)), velocidad_motor);
      if (m == 2 && velocidad_motor != velocidad) {
        Serial.print(" - MODO M3: 35 RPM FIJO");
      } else if (m == 3 && velocidad_motor != velocidad) {
        Serial.print(" - MODO M4: 1000 RPM FIJO");
      }
      Serial.println(")");
      
      moverMotorPorDeltaDeg(m, delta, velocidad_motor);
      if (emergencyStop) {
        Serial.println("‚õî E-STOP activado, abortando secuencia POS.");
        commandInProgress = false;
        return;
      }
      delay(80);
    }
  }

  // ‚úÖ GARRA CORREGIDA: 100¬∞ = Abierto, 0¬∞ = Cerrado
  if (target_deg[4] >= 50.0) { // Umbral a 50¬∞ para abrir/cerrar
    garra.write(posAbierta);
    current_deg[4] = posAbierta;
    Serial.println("üîê Garra abierta (100¬∞) - (POS)");
  } else {
    garra.write(posCerrada);
    current_deg[4] = posCerrada;
    Serial.println("üîì Garra cerrada (0¬∞) - (POS)");
  }

  Serial.println("‚úÖ Movimiento POS completo.");
  commandInProgress = false;
}
